{"version":3,"file":"react-router-dom.production.min.js","sources":["../../lib/dom-export/hydrated-router.tsx","../../lib/dom-export/dom-router-provider.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport type {\n  UNSAFE_AssetsManifest as AssetsManifest,\n  UNSAFE_RouteModules as RouteModules,\n  DataRouter,\n  HydrationState,\n} from \"react-router\";\nimport {\n  UNSAFE_invariant as invariant,\n  UNSAFE_FrameworkContext as FrameworkContext,\n  UNSAFE_decodeViaTurboStream as decodeViaTurboStream,\n  UNSAFE_RemixErrorBoundary as RemixErrorBoundary,\n  UNSAFE_createBrowserHistory as createBrowserHistory,\n  UNSAFE_createClientRoutes as createClientRoutes,\n  UNSAFE_createRouter as createRouter,\n  UNSAFE_deserializeErrors as deserializeErrors,\n  UNSAFE_getSingleFetchDataStrategy as getSingleFetchDataStrategy,\n  UNSAFE_getPatchRoutesOnNavigationFunction as getPatchRoutesOnNavigationFunction,\n  UNSAFE_shouldHydrateRouteLoader as shouldHydrateRouteLoader,\n  UNSAFE_useFogOFWarDiscovery as useFogOFWarDiscovery,\n  UNSAFE_mapRouteProperties as mapRouteProperties,\n  UNSAFE_createClientRoutesWithHMRRevalidationOptOut as createClientRoutesWithHMRRevalidationOptOut,\n  matchRoutes,\n} from \"react-router\";\nimport { RouterProvider } from \"./dom-router-provider\";\n\ntype SSRInfo = {\n  context: NonNullable<(typeof window)[\"__reactRouterContext\"]>;\n  routeModules: RouteModules;\n  manifest: AssetsManifest;\n  stateDecodingPromise:\n    | (Promise<void> & {\n        value?: unknown;\n        error?: unknown;\n      })\n    | undefined;\n  router: DataRouter | undefined;\n  routerInitialized: boolean;\n};\n\nlet ssrInfo: SSRInfo | null = null;\nlet router: DataRouter | null = null;\n\nfunction initSsrInfo(): void {\n  if (\n    !ssrInfo &&\n    window.__reactRouterContext &&\n    window.__reactRouterManifest &&\n    window.__reactRouterRouteModules\n  ) {\n    ssrInfo = {\n      context: window.__reactRouterContext,\n      manifest: window.__reactRouterManifest,\n      routeModules: window.__reactRouterRouteModules,\n      stateDecodingPromise: undefined,\n      router: undefined,\n      routerInitialized: false,\n    };\n  }\n}\n\nfunction createHydratedRouter(): DataRouter {\n  initSsrInfo();\n\n  if (!ssrInfo) {\n    throw new Error(\n      \"You must be using the SSR features of React Router in order to skip \" +\n        \"passing a `router` prop to `<RouterProvider>`\"\n    );\n  }\n\n  // We need to suspend until the initial state snapshot is decoded into\n  // window.__reactRouterContext.state\n\n  let localSsrInfo = ssrInfo;\n  // Note: `stateDecodingPromise` is not coupled to `router` - we'll reach this\n  // code potentially many times waiting for our state to arrive, but we'll\n  // then only get past here and create the `router` one time\n  if (!ssrInfo.stateDecodingPromise) {\n    let stream = ssrInfo.context.stream;\n    invariant(stream, \"No stream found for single fetch decoding\");\n    ssrInfo.context.stream = undefined;\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window)\n      .then((value) => {\n        ssrInfo!.context.state =\n          value.value as typeof localSsrInfo.context.state;\n        localSsrInfo.stateDecodingPromise!.value = true;\n      })\n      .catch((e) => {\n        localSsrInfo.stateDecodingPromise!.error = e;\n      });\n  }\n  if (ssrInfo.stateDecodingPromise.error) {\n    throw ssrInfo.stateDecodingPromise.error;\n  }\n  if (!ssrInfo.stateDecodingPromise.value) {\n    throw ssrInfo.stateDecodingPromise;\n  }\n\n  let routes = createClientRoutes(\n    ssrInfo.manifest.routes,\n    ssrInfo.routeModules,\n    ssrInfo.context.state,\n    ssrInfo.context.isSpaMode\n  );\n\n  let hydrationData: HydrationState | undefined = undefined;\n  if (!ssrInfo.context.isSpaMode) {\n    // Create a shallow clone of `loaderData` we can mutate for partial hydration.\n    // When a route exports a `clientLoader` and a `HydrateFallback`, the SSR will\n    // render the fallback so we need the client to do the same for hydration.\n    // The server loader data has already been exposed to these route `clientLoader`'s\n    // in `createClientRoutes` above, so we need to clear out the version we pass to\n    // `createBrowserRouter` so it initializes and runs the client loaders.\n    hydrationData = {\n      ...ssrInfo.context.state,\n      loaderData: { ...ssrInfo.context.state.loaderData },\n    };\n    let initialMatches = matchRoutes(\n      routes,\n      window.location,\n      window.__reactRouterContext?.basename\n    );\n    if (initialMatches) {\n      for (let match of initialMatches) {\n        let routeId = match.route.id;\n        let route = ssrInfo.routeModules[routeId];\n        let manifestRoute = ssrInfo.manifest.routes[routeId];\n        // Clear out the loaderData to avoid rendering the route component when the\n        // route opted into clientLoader hydration and either:\n        // * gave us a HydrateFallback\n        // * or doesn't have a server loader and we have no data to render\n        if (\n          route &&\n          shouldHydrateRouteLoader(\n            manifestRoute,\n            route,\n            ssrInfo.context.isSpaMode\n          ) &&\n          (route.HydrateFallback || !manifestRoute.hasLoader)\n        ) {\n          delete hydrationData.loaderData![routeId];\n        } else if (manifestRoute && !manifestRoute.hasLoader) {\n          // Since every Remix route gets a `loader` on the client side to load\n          // the route JS module, we need to add a `null` value to `loaderData`\n          // for any routes that don't have server loaders so our partial\n          // hydration logic doesn't kick off the route module loaders during\n          // hydration\n          hydrationData.loaderData![routeId] = null;\n        }\n      }\n    }\n\n    if (hydrationData && hydrationData.errors) {\n      // TODO: De-dup this or remove entirely in v7 where single fetch is the\n      // only approach and we have already serialized or deserialized on the server\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\n    }\n  }\n\n  // We don't use createBrowserRouter here because we need fine-grained control\n  // over initialization to support synchronous `clientLoader` flows.\n  let router = createRouter({\n    routes,\n    history: createBrowserHistory(),\n    basename: ssrInfo.context.basename,\n    hydrationData,\n    mapRouteProperties,\n    dataStrategy: getSingleFetchDataStrategy(\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      () => router\n    ),\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      ssrInfo.context.isSpaMode,\n      ssrInfo.context.basename\n    ),\n  });\n  ssrInfo.router = router;\n\n  // We can call initialize() immediately if the router doesn't have any\n  // loaders to run on hydration\n  if (router.state.initialized) {\n    ssrInfo.routerInitialized = true;\n    router.initialize();\n  }\n\n  // @ts-ignore\n  router.createRoutesForHMR =\n    /* spacer so ts-ignore does not affect the right hand of the assignment */\n    createClientRoutesWithHMRRevalidationOptOut;\n  window.__reactRouterDataRouter = router;\n\n  return router;\n}\n\n/**\n * @category Router Components\n */\nexport function HydratedRouter() {\n  if (!router) {\n    router = createHydratedRouter();\n  }\n\n  // Critical CSS can become stale after code changes, e.g. styles might be\n  // removed from a component, but the styles will still be present in the\n  // server HTML. This allows our HMR logic to clear the critical CSS state.\n  let [criticalCss, setCriticalCss] = React.useState(\n    process.env.NODE_ENV === \"development\"\n      ? ssrInfo?.context.criticalCss\n      : undefined\n  );\n  if (process.env.NODE_ENV === \"development\") {\n    if (ssrInfo) {\n      window.__reactRouterClearCriticalCss = () => setCriticalCss(undefined);\n    }\n  }\n\n  let [location, setLocation] = React.useState(router.state.location);\n\n  React.useLayoutEffect(() => {\n    // If we had to run clientLoaders on hydration, we delay initialization until\n    // after we've hydrated to avoid hydration issues from synchronous client loaders\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n      ssrInfo.routerInitialized = true;\n      ssrInfo.router.initialize();\n    }\n  }, []);\n\n  React.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router) {\n      return ssrInfo.router.subscribe((newState) => {\n        if (newState.location !== location) {\n          setLocation(newState.location);\n        }\n      });\n    }\n  }, [location]);\n\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n\n  useFogOFWarDiscovery(\n    router,\n    ssrInfo.manifest,\n    ssrInfo.routeModules,\n    ssrInfo.context.isSpaMode\n  );\n\n  // We need to include a wrapper RemixErrorBoundary here in case the root error\n  // boundary also throws and we need to bubble up outside of the router entirely.\n  // Then we need a stateful location here so the user can back-button navigate\n  // out of there\n  return (\n    // This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    <>\n      <FrameworkContext.Provider\n        value={{\n          manifest: ssrInfo.manifest,\n          routeModules: ssrInfo.routeModules,\n          future: ssrInfo.context.future,\n          criticalCss,\n          isSpaMode: ssrInfo.context.isSpaMode,\n        }}\n      >\n        <RemixErrorBoundary location={location}>\n          <RouterProvider router={router} />\n        </RemixErrorBoundary>\n      </FrameworkContext.Provider>\n      {/*\n          This fragment is important to ensure we match the <ServerRouter> JSX\n          structure so that useId values hydrate correctly\n        */}\n      <></>\n    </>\n  );\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport type { RouterProviderProps as BaseRouterProviderProps } from \"react-router\";\nimport { RouterProvider as BaseRouterProvider } from \"react-router\";\n\nexport { HydratedRouter } from \"./hydrated-router\";\n\nexport type RouterProviderProps = Omit<BaseRouterProviderProps, \"flushSync\">;\n\nexport function RouterProvider(props: Omit<RouterProviderProps, \"flushSync\">) {\n  return <BaseRouterProvider flushSync={ReactDOM.flushSync} {...props} />;\n}\n"],"names":["ssrInfo","router","createHydratedRouter","window","__reactRouterContext","__reactRouterManifest","__reactRouterRouteModules","context","manifest","routeModules","stateDecodingPromise","undefined","routerInitialized","Error","localSsrInfo","stream","invariant","UNSAFE_invariant","decodeViaTurboStream","then","value","state","catch","e","error","hydrationData","routes","createClientRoutes","UNSAFE_createClientRoutes","isSpaMode","_window$__reactRouter","_extends","loaderData","initialMatches","matchRoutes","location","basename","match","routeId","route","id","manifestRoute","shouldHydrateRouteLoader","UNSAFE_shouldHydrateRouteLoader","HydrateFallback","hasLoader","errors","deserializeErrors","createRouter","history","createBrowserHistory","mapRouteProperties","UNSAFE_mapRouteProperties","dataStrategy","getSingleFetchDataStrategy","UNSAFE_getSingleFetchDataStrategy","patchRoutesOnNavigation","getPatchRoutesOnNavigationFunction","UNSAFE_getPatchRoutesOnNavigationFunction","initialized","initialize","createRoutesForHMR","createClientRoutesWithHMRRevalidationOptOut","__reactRouterDataRouter","RouterProvider","props","React","createElement","BaseRouterProvider","flushSync","ReactDOM","criticalCss","setCriticalCss","useState","setLocation","useLayoutEffect","subscribe","newState","useFogOFWarDiscovery","Fragment","FrameworkContext","UNSAFE_FrameworkContext","Provider","future","RemixErrorBoundary"],"mappings":"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"}