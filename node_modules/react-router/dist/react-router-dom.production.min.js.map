{"version":3,"file":"react-router-dom.production.min.js","sources":["../lib/dom-export/hydrated-router.tsx","../lib/dom-export/dom-router-provider.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport type {\n  UNSAFE_AssetsManifest as AssetsManifest,\n  UNSAFE_RouteModules as RouteModules,\n  DataRouter,\n  HydrationState,\n} from \"react-router\";\nimport {\n  UNSAFE_invariant as invariant,\n  UNSAFE_FrameworkContext as FrameworkContext,\n  UNSAFE_decodeViaTurboStream as decodeViaTurboStream,\n  UNSAFE_RemixErrorBoundary as RemixErrorBoundary,\n  UNSAFE_createBrowserHistory as createBrowserHistory,\n  UNSAFE_createClientRoutes as createClientRoutes,\n  UNSAFE_createRouter as createRouter,\n  UNSAFE_deserializeErrors as deserializeErrors,\n  UNSAFE_getSingleFetchDataStrategy as getSingleFetchDataStrategy,\n  UNSAFE_getPatchRoutesOnNavigationFunction as getPatchRoutesOnNavigationFunction,\n  UNSAFE_shouldHydrateRouteLoader as shouldHydrateRouteLoader,\n  UNSAFE_useFogOFWarDiscovery as useFogOFWarDiscovery,\n  UNSAFE_mapRouteProperties as mapRouteProperties,\n  UNSAFE_createClientRoutesWithHMRRevalidationOptOut as createClientRoutesWithHMRRevalidationOptOut,\n  matchRoutes,\n} from \"react-router\";\nimport { RouterProvider } from \"./dom-router-provider\";\n\ntype SSRInfo = {\n  context: NonNullable<(typeof window)[\"__reactRouterContext\"]>;\n  routeModules: RouteModules;\n  manifest: AssetsManifest;\n  stateDecodingPromise:\n    | (Promise<void> & {\n        value?: unknown;\n        error?: unknown;\n      })\n    | undefined;\n  router: DataRouter | undefined;\n  routerInitialized: boolean;\n};\n\nlet ssrInfo: SSRInfo | null = null;\nlet router: DataRouter | null = null;\n\nfunction initSsrInfo(): void {\n  if (\n    !ssrInfo &&\n    window.__reactRouterContext &&\n    window.__reactRouterManifest &&\n    window.__reactRouterRouteModules\n  ) {\n    ssrInfo = {\n      context: window.__reactRouterContext,\n      manifest: window.__reactRouterManifest,\n      routeModules: window.__reactRouterRouteModules,\n      stateDecodingPromise: undefined,\n      router: undefined,\n      routerInitialized: false,\n    };\n  }\n}\n\nfunction createHydratedRouter(): DataRouter {\n  initSsrInfo();\n\n  if (!ssrInfo) {\n    throw new Error(\n      \"You must be using the SSR features of React Router in order to skip \" +\n        \"passing a `router` prop to `<RouterProvider>`\"\n    );\n  }\n\n  // We need to suspend until the initial state snapshot is decoded into\n  // window.__reactRouterContext.state\n\n  let localSsrInfo = ssrInfo;\n  // Note: `stateDecodingPromise` is not coupled to `router` - we'll reach this\n  // code potentially many times waiting for our state to arrive, but we'll\n  // then only get past here and create the `router` one time\n  if (!ssrInfo.stateDecodingPromise) {\n    let stream = ssrInfo.context.stream;\n    invariant(stream, \"No stream found for single fetch decoding\");\n    ssrInfo.context.stream = undefined;\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window)\n      .then((value) => {\n        ssrInfo!.context.state =\n          value.value as typeof localSsrInfo.context.state;\n        localSsrInfo.stateDecodingPromise!.value = true;\n      })\n      .catch((e) => {\n        localSsrInfo.stateDecodingPromise!.error = e;\n      });\n  }\n  if (ssrInfo.stateDecodingPromise.error) {\n    throw ssrInfo.stateDecodingPromise.error;\n  }\n  if (!ssrInfo.stateDecodingPromise.value) {\n    throw ssrInfo.stateDecodingPromise;\n  }\n\n  let routes = createClientRoutes(\n    ssrInfo.manifest.routes,\n    ssrInfo.routeModules,\n    ssrInfo.context.state,\n    ssrInfo.context.isSpaMode\n  );\n\n  let hydrationData: HydrationState | undefined = undefined;\n  if (!ssrInfo.context.isSpaMode) {\n    // Create a shallow clone of `loaderData` we can mutate for partial hydration.\n    // When a route exports a `clientLoader` and a `HydrateFallback`, the SSR will\n    // render the fallback so we need the client to do the same for hydration.\n    // The server loader data has already been exposed to these route `clientLoader`'s\n    // in `createClientRoutes` above, so we need to clear out the version we pass to\n    // `createBrowserRouter` so it initializes and runs the client loaders.\n    hydrationData = {\n      ...ssrInfo.context.state,\n      loaderData: { ...ssrInfo.context.state.loaderData },\n    };\n    let initialMatches = matchRoutes(\n      routes,\n      window.location,\n      window.__reactRouterContext?.basename\n    );\n    if (initialMatches) {\n      for (let match of initialMatches) {\n        let routeId = match.route.id;\n        let route = ssrInfo.routeModules[routeId];\n        let manifestRoute = ssrInfo.manifest.routes[routeId];\n        // Clear out the loaderData to avoid rendering the route component when the\n        // route opted into clientLoader hydration and either:\n        // * gave us a HydrateFallback\n        // * or doesn't have a server loader and we have no data to render\n        if (\n          route &&\n          shouldHydrateRouteLoader(\n            manifestRoute,\n            route,\n            ssrInfo.context.isSpaMode\n          ) &&\n          (route.HydrateFallback || !manifestRoute.hasLoader)\n        ) {\n          delete hydrationData.loaderData![routeId];\n        } else if (manifestRoute && !manifestRoute.hasLoader) {\n          // Since every Remix route gets a `loader` on the client side to load\n          // the route JS module, we need to add a `null` value to `loaderData`\n          // for any routes that don't have server loaders so our partial\n          // hydration logic doesn't kick off the route module loaders during\n          // hydration\n          hydrationData.loaderData![routeId] = null;\n        }\n      }\n    }\n\n    if (hydrationData && hydrationData.errors) {\n      // TODO: De-dup this or remove entirely in v7 where single fetch is the\n      // only approach and we have already serialized or deserialized on the server\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\n    }\n  }\n\n  // We don't use createBrowserRouter here because we need fine-grained control\n  // over initialization to support synchronous `clientLoader` flows.\n  let router = createRouter({\n    routes,\n    history: createBrowserHistory(),\n    basename: ssrInfo.context.basename,\n    hydrationData,\n    mapRouteProperties,\n    dataStrategy: getSingleFetchDataStrategy(\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      () => router\n    ),\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(\n      ssrInfo.manifest,\n      ssrInfo.routeModules,\n      ssrInfo.context.isSpaMode,\n      ssrInfo.context.basename\n    ),\n  });\n  ssrInfo.router = router;\n\n  // We can call initialize() immediately if the router doesn't have any\n  // loaders to run on hydration\n  if (router.state.initialized) {\n    ssrInfo.routerInitialized = true;\n    router.initialize();\n  }\n\n  // @ts-ignore\n  router.createRoutesForHMR =\n    /* spacer so ts-ignore does not affect the right hand of the assignment */\n    createClientRoutesWithHMRRevalidationOptOut;\n  window.__reactRouterDataRouter = router;\n\n  return router;\n}\n\n/**\n * @category Router Components\n */\nexport function HydratedRouter() {\n  if (!router) {\n    router = createHydratedRouter();\n  }\n\n  // Critical CSS can become stale after code changes, e.g. styles might be\n  // removed from a component, but the styles will still be present in the\n  // server HTML. This allows our HMR logic to clear the critical CSS state.\n  let [criticalCss, setCriticalCss] = React.useState(\n    process.env.NODE_ENV === \"development\"\n      ? ssrInfo?.context.criticalCss\n      : undefined\n  );\n  if (process.env.NODE_ENV === \"development\") {\n    if (ssrInfo) {\n      window.__reactRouterClearCriticalCss = () => setCriticalCss(undefined);\n    }\n  }\n\n  let [location, setLocation] = React.useState(router.state.location);\n\n  React.useLayoutEffect(() => {\n    // If we had to run clientLoaders on hydration, we delay initialization until\n    // after we've hydrated to avoid hydration issues from synchronous client loaders\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n      ssrInfo.routerInitialized = true;\n      ssrInfo.router.initialize();\n    }\n  }, []);\n\n  React.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router) {\n      return ssrInfo.router.subscribe((newState) => {\n        if (newState.location !== location) {\n          setLocation(newState.location);\n        }\n      });\n    }\n  }, [location]);\n\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n\n  useFogOFWarDiscovery(\n    router,\n    ssrInfo.manifest,\n    ssrInfo.routeModules,\n    ssrInfo.context.isSpaMode\n  );\n\n  // We need to include a wrapper RemixErrorBoundary here in case the root error\n  // boundary also throws and we need to bubble up outside of the router entirely.\n  // Then we need a stateful location here so the user can back-button navigate\n  // out of there\n  return (\n    // This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    <>\n      <FrameworkContext.Provider\n        value={{\n          manifest: ssrInfo.manifest,\n          routeModules: ssrInfo.routeModules,\n          future: ssrInfo.context.future,\n          criticalCss,\n          isSpaMode: ssrInfo.context.isSpaMode,\n        }}\n      >\n        <RemixErrorBoundary location={location}>\n          <RouterProvider router={router} />\n        </RemixErrorBoundary>\n      </FrameworkContext.Provider>\n      {/*\n          This fragment is important to ensure we match the <ServerRouter> JSX\n          structure so that useId values hydrate correctly\n        */}\n      <></>\n    </>\n  );\n}\n","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\n\nimport type { RouterProviderProps as BaseRouterProviderProps } from \"react-router\";\nimport { RouterProvider as BaseRouterProvider } from \"react-router\";\n\nexport { HydratedRouter } from \"./hydrated-router\";\n\nexport type RouterProviderProps = Omit<BaseRouterProviderProps, \"flushSync\">;\n\nexport function RouterProvider(props: Omit<RouterProviderProps, \"flushSync\">) {\n  return <BaseRouterProvider flushSync={ReactDOM.flushSync} {...props} />;\n}\n"],"names":["ssrInfo","router","createHydratedRouter","window","__reactRouterContext","__reactRouterManifest","__reactRouterRouteModules","context","manifest","routeModules","stateDecodingPromise","undefined","routerInitialized","Error","localSsrInfo","stream","invariant","decodeViaTurboStream","then","value","state","catch","e","error","hydrationData","routes","createClientRoutes","isSpaMode","loaderData","initialMatches","matchRoutes","location","basename","match","routeId","route","id","manifestRoute","shouldHydrateRouteLoader","HydrateFallback","hasLoader","errors","deserializeErrors","createRouter","history","createBrowserHistory","mapRouteProperties","dataStrategy","getSingleFetchDataStrategy","patchRoutesOnNavigation","getPatchRoutesOnNavigationFunction","initialized","initialize","createRoutesForHMR","createClientRoutesWithHMRRevalidationOptOut","__reactRouterDataRouter","HydratedRouter","criticalCss","setCriticalCss","React","useState","setLocation","useLayoutEffect","subscribe","newState","useFogOFWarDiscovery","createElement","Fragment","FrameworkContext","Provider","future","RemixErrorBoundary","RouterProvider","props","BaseRouterProvider","Object","assign","flushSync","ReactDOM"],"mappings":"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"}